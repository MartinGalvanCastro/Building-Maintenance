/* tslint:disable */
/* eslint-disable */
/**
 * Building Maintenance API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CancelResponseDto
 */
export interface CancelResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CancelResponseDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ChangeStatusDto
 */
export interface ChangeStatusDto {
    /**
     * 
     * @type {string}
     * @memberof ChangeStatusDto
     */
    'status': ChangeStatusDtoStatusEnum;
}

export const ChangeStatusDtoStatusEnum = {
    Pending: 'PENDING',
    Scheduled: 'SCHEDULED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type ChangeStatusDtoStatusEnum = typeof ChangeStatusDtoStatusEnum[keyof typeof ChangeStatusDtoStatusEnum];

/**
 * Payload for creating a new maintenance request. Resident ID is required.
 * @export
 * @interface CreateMaintenanceRequestDto
 */
export interface CreateMaintenanceRequestDto {
    /**
     * ID of the resident making the request
     * @type {string}
     * @memberof CreateMaintenanceRequestDto
     */
    'residentId': string;
    /**
     * Description of the maintenance issue
     * @type {string}
     * @memberof CreateMaintenanceRequestDto
     */
    'description': string;
    /**
     * Required technician specialization
     * @type {string}
     * @memberof CreateMaintenanceRequestDto
     */
    'specialization': CreateMaintenanceRequestDtoSpecializationEnum;
    /**
     * Scheduled date and time for the maintenance
     * @type {string}
     * @memberof CreateMaintenanceRequestDto
     */
    'scheduledAt': string;
}

export const CreateMaintenanceRequestDtoSpecializationEnum = {
    Electrical: 'ELECTRICAL',
    Plumbing: 'PLUMBING',
    Hvac: 'HVAC',
    Carpentry: 'CARPENTRY',
    Other: 'OTHER'
} as const;

export type CreateMaintenanceRequestDtoSpecializationEnum = typeof CreateMaintenanceRequestDtoSpecializationEnum[keyof typeof CreateMaintenanceRequestDtoSpecializationEnum];

/**
 * 
 * @export
 * @interface CreateRequestDto
 */
export interface CreateRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRequestDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRequestDto
     */
    'specialization': CreateRequestDtoSpecializationEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateRequestDto
     */
    'scheduledAt': string;
}

export const CreateRequestDtoSpecializationEnum = {
    Electrical: 'ELECTRICAL',
    Plumbing: 'PLUMBING',
    Hvac: 'HVAC',
    Carpentry: 'CARPENTRY',
    Other: 'OTHER'
} as const;

export type CreateRequestDtoSpecializationEnum = typeof CreateRequestDtoSpecializationEnum[keyof typeof CreateRequestDtoSpecializationEnum];

/**
 * DTO containing user credentials for authentication.
 * @export
 * @interface CredentialsDto
 */
export interface CredentialsDto {
    /**
     * User\'s email address.
     * @type {string}
     * @memberof CredentialsDto
     */
    'email': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof CredentialsDto
     */
    'password': string;
}
/**
 * DTO returned after deleting a resource, containing a message about the operation result.
 * @export
 * @interface DeleteResponseDto
 */
export interface DeleteResponseDto {
    /**
     * Message describing the result of the delete operation.
     * @type {string}
     * @memberof DeleteResponseDto
     */
    'message'?: string;
}
/**
 * DTO returned after successful authentication, containing the JWT token.
 * @export
 * @interface LogInResultDto
 */
export interface LogInResultDto {
    /**
     * JWT token for authenticated user.
     * @type {string}
     * @memberof LogInResultDto
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface MaintenanceRequestDto
 */
export interface MaintenanceRequestDto {
    /**
     * 
     * @type {string}
     * @memberof MaintenanceRequestDto
     */
    'id'?: string;
    /**
     * 
     * @type {ResidentSummaryDto}
     * @memberof MaintenanceRequestDto
     */
    'resident'?: ResidentSummaryDto;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceRequestDto
     */
    'specialization'?: MaintenanceRequestDtoSpecializationEnum;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceRequestDto
     */
    'status'?: MaintenanceRequestDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceRequestDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceRequestDto
     */
    'scheduledAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceRequestDto
     */
    'completedAt'?: string;
    /**
     * 
     * @type {TechnicianSummaryDto}
     * @memberof MaintenanceRequestDto
     */
    'technician'?: TechnicianSummaryDto;
}

export const MaintenanceRequestDtoSpecializationEnum = {
    Electrical: 'ELECTRICAL',
    Plumbing: 'PLUMBING',
    Hvac: 'HVAC',
    Carpentry: 'CARPENTRY',
    Other: 'OTHER'
} as const;

export type MaintenanceRequestDtoSpecializationEnum = typeof MaintenanceRequestDtoSpecializationEnum[keyof typeof MaintenanceRequestDtoSpecializationEnum];
export const MaintenanceRequestDtoStatusEnum = {
    Pending: 'PENDING',
    Scheduled: 'SCHEDULED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type MaintenanceRequestDtoStatusEnum = typeof MaintenanceRequestDtoStatusEnum[keyof typeof MaintenanceRequestDtoStatusEnum];

/**
 * Summary information about a maintenance request, including related technician and resident.
 * @export
 * @interface MaintenanceRequestSummaryDto
 */
export interface MaintenanceRequestSummaryDto {
    /**
     * Unique identifier of the maintenance request.
     * @type {string}
     * @memberof MaintenanceRequestSummaryDto
     */
    'id'?: string;
    /**
     * Status of the maintenance request.
     * @type {string}
     * @memberof MaintenanceRequestSummaryDto
     */
    'status'?: string;
    /**
     * Date and time when the request was created.
     * @type {string}
     * @memberof MaintenanceRequestSummaryDto
     */
    'createdAt'?: string;
    /**
     * Description of the maintenance request.
     * @type {string}
     * @memberof MaintenanceRequestSummaryDto
     */
    'description'?: string;
    /**
     * Specialization required for the request.
     * @type {string}
     * @memberof MaintenanceRequestSummaryDto
     */
    'specialization'?: string;
    /**
     * Scheduled date and time for the request.
     * @type {string}
     * @memberof MaintenanceRequestSummaryDto
     */
    'scheduledAt'?: string;
    /**
     * Summary of the assigned technician.
     * @type {TechnicianSummaryDto}
     * @memberof MaintenanceRequestSummaryDto
     */
    'technician'?: TechnicianSummaryDto;
    /**
     * Summary of the resident who made the request.
     * @type {ResidentSummaryDto}
     * @memberof MaintenanceRequestSummaryDto
     */
    'resident'?: ResidentSummaryDto;
}
/**
 * 
 * @export
 * @interface ResidentCreateCommandDto
 */
export interface ResidentCreateCommandDto {
    /**
     * 
     * @type {string}
     * @memberof ResidentCreateCommandDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof ResidentCreateCommandDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ResidentCreateCommandDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ResidentCreateCommandDto
     */
    'unitNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ResidentCreateCommandDto
     */
    'unitBlock': string;
    /**
     * 
     * @type {string}
     * @memberof ResidentCreateCommandDto
     */
    'residentialComplexId': string;
}
/**
 * 
 * @export
 * @interface ResidentDto
 */
export interface ResidentDto {
    /**
     * 
     * @type {string}
     * @memberof ResidentDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResidentDto
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResidentDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResidentDto
     */
    'unitNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResidentDto
     */
    'unitBlock'?: string;
    /**
     * 
     * @type {ResidentialComplexDto}
     * @memberof ResidentDto
     */
    'residentialComplex'?: ResidentialComplexDto;
}
/**
 * 
 * @export
 * @interface ResidentSummaryDto
 */
export interface ResidentSummaryDto {
    /**
     * 
     * @type {string}
     * @memberof ResidentSummaryDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResidentSummaryDto
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResidentSummaryDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResidentSummaryDto
     */
    'unitNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResidentSummaryDto
     */
    'unitBlock'?: string;
    /**
     * 
     * @type {ResidentialComplexDto}
     * @memberof ResidentSummaryDto
     */
    'residentialComplex'?: ResidentialComplexDto;
}
/**
 * 
 * @export
 * @interface ResidentUpdateCommandDto
 */
export interface ResidentUpdateCommandDto {
    /**
     * 
     * @type {string}
     * @memberof ResidentUpdateCommandDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof ResidentUpdateCommandDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ResidentUpdateCommandDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResidentUpdateCommandDto
     */
    'unitNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ResidentUpdateCommandDto
     */
    'unitBlock': string;
    /**
     * 
     * @type {string}
     * @memberof ResidentUpdateCommandDto
     */
    'residentialComplexId'?: string;
}
/**
 * DTO used to create or update a residential complex.
 * @export
 * @interface ResidentialComplexCommandDto
 */
export interface ResidentialComplexCommandDto {
    /**
     * Name of the residential complex.
     * @type {string}
     * @memberof ResidentialComplexCommandDto
     */
    'name': string;
    /**
     * Address of the residential complex.
     * @type {string}
     * @memberof ResidentialComplexCommandDto
     */
    'address': string;
    /**
     * City where the residential complex is located.
     * @type {string}
     * @memberof ResidentialComplexCommandDto
     */
    'city': string;
    /**
     * Postal code of the residential complex.
     * @type {string}
     * @memberof ResidentialComplexCommandDto
     */
    'postalCode': string;
}
/**
 * Summary information about a residential complex.
 * @export
 * @interface ResidentialComplexDto
 */
export interface ResidentialComplexDto {
    /**
     * Unique identifier of the residential complex.
     * @type {string}
     * @memberof ResidentialComplexDto
     */
    'id'?: string;
    /**
     * Name of the residential complex.
     * @type {string}
     * @memberof ResidentialComplexDto
     */
    'name'?: string;
    /**
     * Address of the residential complex.
     * @type {string}
     * @memberof ResidentialComplexDto
     */
    'address'?: string;
    /**
     * City where the residential complex is located.
     * @type {string}
     * @memberof ResidentialComplexDto
     */
    'city'?: string;
    /**
     * Postal code of the residential complex.
     * @type {string}
     * @memberof ResidentialComplexDto
     */
    'postalCode'?: string;
}
/**
 * 
 * @export
 * @interface TechnicianCreateCommandDto
 */
export interface TechnicianCreateCommandDto {
    /**
     * 
     * @type {string}
     * @memberof TechnicianCreateCommandDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof TechnicianCreateCommandDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TechnicianCreateCommandDto
     */
    'password': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TechnicianCreateCommandDto
     */
    'specializations': Array<TechnicianCreateCommandDtoSpecializationsEnum>;
}

export const TechnicianCreateCommandDtoSpecializationsEnum = {
    Electrical: 'ELECTRICAL',
    Plumbing: 'PLUMBING',
    Hvac: 'HVAC',
    Carpentry: 'CARPENTRY',
    Other: 'OTHER'
} as const;

export type TechnicianCreateCommandDtoSpecializationsEnum = typeof TechnicianCreateCommandDtoSpecializationsEnum[keyof typeof TechnicianCreateCommandDtoSpecializationsEnum];

/**
 * 
 * @export
 * @interface TechnicianDto
 */
export interface TechnicianDto {
    /**
     * 
     * @type {string}
     * @memberof TechnicianDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TechnicianDto
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TechnicianDto
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TechnicianDto
     */
    'specializations'?: Array<TechnicianDtoSpecializationsEnum>;
}

export const TechnicianDtoSpecializationsEnum = {
    Electrical: 'ELECTRICAL',
    Plumbing: 'PLUMBING',
    Hvac: 'HVAC',
    Carpentry: 'CARPENTRY',
    Other: 'OTHER'
} as const;

export type TechnicianDtoSpecializationsEnum = typeof TechnicianDtoSpecializationsEnum[keyof typeof TechnicianDtoSpecializationsEnum];

/**
 * Summary information about a technician.
 * @export
 * @interface TechnicianSummaryDto
 */
export interface TechnicianSummaryDto {
    /**
     * Unique identifier of the technician.
     * @type {string}
     * @memberof TechnicianSummaryDto
     */
    'id'?: string;
    /**
     * Full name of the technician.
     * @type {string}
     * @memberof TechnicianSummaryDto
     */
    'fullName'?: string;
    /**
     * Email address of the technician.
     * @type {string}
     * @memberof TechnicianSummaryDto
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface TechnicianUpdateCommandDto
 */
export interface TechnicianUpdateCommandDto {
    /**
     * 
     * @type {string}
     * @memberof TechnicianUpdateCommandDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof TechnicianUpdateCommandDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TechnicianUpdateCommandDto
     */
    'password'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TechnicianUpdateCommandDto
     */
    'specializations': Array<TechnicianUpdateCommandDtoSpecializationsEnum>;
}

export const TechnicianUpdateCommandDtoSpecializationsEnum = {
    Electrical: 'ELECTRICAL',
    Plumbing: 'PLUMBING',
    Hvac: 'HVAC',
    Carpentry: 'CARPENTRY',
    Other: 'OTHER'
} as const;

export type TechnicianUpdateCommandDtoSpecializationsEnum = typeof TechnicianUpdateCommandDtoSpecializationsEnum[keyof typeof TechnicianUpdateCommandDtoSpecializationsEnum];

/**
 * 
 * @export
 * @interface UpdateRequestDto
 */
export interface UpdateRequestDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRequestDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequestDto
     */
    'scheduledAt': string;
}
/**
 * DTO containing user info, relationships, and related maintenance requests for the /me endpoint.
 * @export
 * @interface UserInfoDto
 */
export interface UserInfoDto {
    /**
     * Unique identifier of the user.
     * @type {string}
     * @memberof UserInfoDto
     */
    'id'?: string;
    /**
     * Full name of the user.
     * @type {string}
     * @memberof UserInfoDto
     */
    'name'?: string;
    /**
     * Email address of the user.
     * @type {string}
     * @memberof UserInfoDto
     */
    'email'?: string;
    /**
     * Role of the user (e.g., RESIDENT, ADMIN, TECHNICIAN).
     * @type {string}
     * @memberof UserInfoDto
     */
    'role'?: UserInfoDtoRoleEnum;
    /**
     * Residential complex info (only for residents).
     * @type {ResidentialComplexDto}
     * @memberof UserInfoDto
     */
    'residentialComplex'?: ResidentialComplexDto;
    /**
     * List of related maintenance requests.
     * @type {Array<MaintenanceRequestSummaryDto>}
     * @memberof UserInfoDto
     */
    'maintenanceRequests'?: Array<MaintenanceRequestSummaryDto>;
}

export const UserInfoDtoRoleEnum = {
    Admin: 'ADMIN',
    Technician: 'TECHNICIAN',
    Resident: 'RESIDENT'
} as const;

export type UserInfoDtoRoleEnum = typeof UserInfoDtoRoleEnum[keyof typeof UserInfoDtoRoleEnum];


/**
 * ActuatorApi - axios parameter creator
 * @export
 */
export const ActuatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActuatorApi - functional programming interface
 * @export
 */
export const ActuatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActuatorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.health']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActuatorApi - factory interface
 * @export
 */
export const ActuatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActuatorApiFp(configuration)
    return {
        /**
         * 
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActuatorApi - object-oriented interface
 * @export
 * @class ActuatorApi
 * @extends {BaseAPI}
 */
export class ActuatorApi extends BaseAPI {
    /**
     * 
     * @summary Actuator web endpoint \'health\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public health(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticates a user with email and password. Returns a JWT token if successful.
         * @summary Authenticate user and return JWT token
         * @param {CredentialsDto} credentialsDto User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (credentialsDto: CredentialsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsDto' is not null or undefined
            assertParamExists('login', 'credentialsDto', credentialsDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentialsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out the user by invalidating the JWT token.
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns 200 if the provided JWT token is valid, 401 if not.
         * @summary Check if a JWT token is valid
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('validateToken', 'authorization', authorization)
            const localVarPath = `/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticates a user with email and password. Returns a JWT token if successful.
         * @summary Authenticate user and return JWT token
         * @param {CredentialsDto} credentialsDto User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(credentialsDto: CredentialsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogInResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(credentialsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs out the user by invalidating the JWT token.
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns 200 if the provided JWT token is valid, 401 if not.
         * @summary Check if a JWT token is valid
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateToken(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateToken(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.validateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Authenticates a user with email and password. Returns a JWT token if successful.
         * @summary Authenticate user and return JWT token
         * @param {CredentialsDto} credentialsDto User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(credentialsDto: CredentialsDto, options?: RawAxiosRequestConfig): AxiosPromise<LogInResultDto> {
            return localVarFp.login(credentialsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Logs out the user by invalidating the JWT token.
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns 200 if the provided JWT token is valid, 401 if not.
         * @summary Check if a JWT token is valid
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken(authorization: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validateToken(authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Authenticates a user with email and password. Returns a JWT token if successful.
     * @summary Authenticate user and return JWT token
     * @param {CredentialsDto} credentialsDto User credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(credentialsDto: CredentialsDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(credentialsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs out the user by invalidating the JWT token.
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns 200 if the provided JWT token is valid, 401 if not.
     * @summary Check if a JWT token is valid
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public validateToken(authorization: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).validateToken(authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MaintenanceRequestManagementApi - axios parameter creator
 * @export
 */
export const MaintenanceRequestManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a technician to a maintenance request by their IDs.
         * @summary Assign a technician to a maintenance request
         * @param {string} id UUID of the maintenance request
         * @param {string} technicianId UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assign: async (id: string, technicianId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assign', 'id', id)
            // verify required parameter 'technicianId' is not null or undefined
            assertParamExists('assign', 'technicianId', technicianId)
            const localVarPath = `/maintenance-requests/{id}/technician/{technicianId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"technicianId"}}`, encodeURIComponent(String(technicianId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new maintenance request.
         * @summary Create a new maintenance request
         * @param {CreateMaintenanceRequestDto} createMaintenanceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4: async (createMaintenanceRequestDto: CreateMaintenanceRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMaintenanceRequestDto' is not null or undefined
            assertParamExists('create4', 'createMaintenanceRequestDto', createMaintenanceRequestDto)
            const localVarPath = `/maintenance-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMaintenanceRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a maintenance request by its ID.
         * @summary Delete a maintenance request
         * @param {string} id UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete3', 'id', id)
            const localVarPath = `/maintenance-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a maintenance request by its unique identifier.
         * @summary Get a maintenance request by ID
         * @param {string} id UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne3: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOne3', 'id', id)
            const localVarPath = `/maintenance-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all maintenance requests.
         * @summary List all maintenance requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll3: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/maintenance-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing maintenance request.
         * @summary Update a maintenance request
         * @param {string} id UUID of the maintenance request
         * @param {UpdateRequestDto} updateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3: async (id: string, updateRequestDto: UpdateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update3', 'id', id)
            // verify required parameter 'updateRequestDto' is not null or undefined
            assertParamExists('update3', 'updateRequestDto', updateRequestDto)
            const localVarPath = `/maintenance-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaintenanceRequestManagementApi - functional programming interface
 * @export
 */
export const MaintenanceRequestManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaintenanceRequestManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a technician to a maintenance request by their IDs.
         * @summary Assign a technician to a maintenance request
         * @param {string} id UUID of the maintenance request
         * @param {string} technicianId UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assign(id: string, technicianId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assign(id, technicianId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceRequestManagementApi.assign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new maintenance request.
         * @summary Create a new maintenance request
         * @param {CreateMaintenanceRequestDto} createMaintenanceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create4(createMaintenanceRequestDto: CreateMaintenanceRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create4(createMaintenanceRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceRequestManagementApi.create4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a maintenance request by its ID.
         * @summary Delete a maintenance request
         * @param {string} id UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete3(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceRequestManagementApi.delete3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a maintenance request by its unique identifier.
         * @summary Get a maintenance request by ID
         * @param {string} id UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOne3(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOne3(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceRequestManagementApi.getOne3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all maintenance requests.
         * @summary List all maintenance requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAll3(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaintenanceRequestDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAll3(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceRequestManagementApi.listAll3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing maintenance request.
         * @summary Update a maintenance request
         * @param {string} id UUID of the maintenance request
         * @param {UpdateRequestDto} updateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update3(id: string, updateRequestDto: UpdateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update3(id, updateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceRequestManagementApi.update3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaintenanceRequestManagementApi - factory interface
 * @export
 */
export const MaintenanceRequestManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaintenanceRequestManagementApiFp(configuration)
    return {
        /**
         * Assigns a technician to a maintenance request by their IDs.
         * @summary Assign a technician to a maintenance request
         * @param {string} id UUID of the maintenance request
         * @param {string} technicianId UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assign(id: string, technicianId: string, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceRequestDto> {
            return localVarFp.assign(id, technicianId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new maintenance request.
         * @summary Create a new maintenance request
         * @param {CreateMaintenanceRequestDto} createMaintenanceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(createMaintenanceRequestDto: CreateMaintenanceRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceRequestDto> {
            return localVarFp.create4(createMaintenanceRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a maintenance request by its ID.
         * @summary Delete a maintenance request
         * @param {string} id UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteResponseDto> {
            return localVarFp.delete3(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a maintenance request by its unique identifier.
         * @summary Get a maintenance request by ID
         * @param {string} id UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne3(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceRequestDto> {
            return localVarFp.getOne3(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all maintenance requests.
         * @summary List all maintenance requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll3(options?: RawAxiosRequestConfig): AxiosPromise<Array<MaintenanceRequestDto>> {
            return localVarFp.listAll3(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing maintenance request.
         * @summary Update a maintenance request
         * @param {string} id UUID of the maintenance request
         * @param {UpdateRequestDto} updateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3(id: string, updateRequestDto: UpdateRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceRequestDto> {
            return localVarFp.update3(id, updateRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaintenanceRequestManagementApi - object-oriented interface
 * @export
 * @class MaintenanceRequestManagementApi
 * @extends {BaseAPI}
 */
export class MaintenanceRequestManagementApi extends BaseAPI {
    /**
     * Assigns a technician to a maintenance request by their IDs.
     * @summary Assign a technician to a maintenance request
     * @param {string} id UUID of the maintenance request
     * @param {string} technicianId UUID of the technician
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceRequestManagementApi
     */
    public assign(id: string, technicianId: string, options?: RawAxiosRequestConfig) {
        return MaintenanceRequestManagementApiFp(this.configuration).assign(id, technicianId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new maintenance request.
     * @summary Create a new maintenance request
     * @param {CreateMaintenanceRequestDto} createMaintenanceRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceRequestManagementApi
     */
    public create4(createMaintenanceRequestDto: CreateMaintenanceRequestDto, options?: RawAxiosRequestConfig) {
        return MaintenanceRequestManagementApiFp(this.configuration).create4(createMaintenanceRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a maintenance request by its ID.
     * @summary Delete a maintenance request
     * @param {string} id UUID of the maintenance request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceRequestManagementApi
     */
    public delete3(id: string, options?: RawAxiosRequestConfig) {
        return MaintenanceRequestManagementApiFp(this.configuration).delete3(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a maintenance request by its unique identifier.
     * @summary Get a maintenance request by ID
     * @param {string} id UUID of the maintenance request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceRequestManagementApi
     */
    public getOne3(id: string, options?: RawAxiosRequestConfig) {
        return MaintenanceRequestManagementApiFp(this.configuration).getOne3(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all maintenance requests.
     * @summary List all maintenance requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceRequestManagementApi
     */
    public listAll3(options?: RawAxiosRequestConfig) {
        return MaintenanceRequestManagementApiFp(this.configuration).listAll3(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing maintenance request.
     * @summary Update a maintenance request
     * @param {string} id UUID of the maintenance request
     * @param {UpdateRequestDto} updateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceRequestManagementApi
     */
    public update3(id: string, updateRequestDto: UpdateRequestDto, options?: RawAxiosRequestConfig) {
        return MaintenanceRequestManagementApiFp(this.configuration).update3(id, updateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResidentMaintenanceRequestsApi - axios parameter creator
 * @export
 */
export const ResidentMaintenanceRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a maintenance request for the specified resident.
         * @summary Cancel a maintenance request for a resident
         * @param {string} residentId UUID of the resident
         * @param {string} requestId UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (residentId: string, requestId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'residentId' is not null or undefined
            assertParamExists('cancel', 'residentId', residentId)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('cancel', 'requestId', requestId)
            const localVarPath = `/residents/{residentId}/requests/{requestId}`
                .replace(`{${"residentId"}}`, encodeURIComponent(String(residentId)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new maintenance request for the specified resident.
         * @summary Create a new maintenance request for a resident
         * @param {string} residentId UUID of the resident
         * @param {CreateRequestDto} createRequestDto Maintenance request creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2: async (residentId: string, createRequestDto: CreateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'residentId' is not null or undefined
            assertParamExists('create2', 'residentId', residentId)
            // verify required parameter 'createRequestDto' is not null or undefined
            assertParamExists('create2', 'createRequestDto', createRequestDto)
            const localVarPath = `/residents/{residentId}/requests`
                .replace(`{${"residentId"}}`, encodeURIComponent(String(residentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a maintenance request by its unique identifier for the specified resident.
         * @summary Get a maintenance request by ID for a resident
         * @param {string} residentId UUID of the resident
         * @param {string} requestId UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (residentId: string, requestId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'residentId' is not null or undefined
            assertParamExists('get', 'residentId', residentId)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('get', 'requestId', requestId)
            const localVarPath = `/residents/{residentId}/requests/{requestId}`
                .replace(`{${"residentId"}}`, encodeURIComponent(String(residentId)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all maintenance requests for the specified resident.
         * @summary List all maintenance requests for a resident
         * @param {string} residentId UUID of the resident
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (residentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'residentId' is not null or undefined
            assertParamExists('list', 'residentId', residentId)
            const localVarPath = `/residents/{residentId}/requests`
                .replace(`{${"residentId"}}`, encodeURIComponent(String(residentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing maintenance request for the specified resident.
         * @summary Update a maintenance request for a resident
         * @param {string} residentId UUID of the resident
         * @param {string} requestId UUID of the maintenance request
         * @param {UpdateRequestDto} updateRequestDto Maintenance request update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4: async (residentId: string, requestId: string, updateRequestDto: UpdateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'residentId' is not null or undefined
            assertParamExists('update4', 'residentId', residentId)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('update4', 'requestId', requestId)
            // verify required parameter 'updateRequestDto' is not null or undefined
            assertParamExists('update4', 'updateRequestDto', updateRequestDto)
            const localVarPath = `/residents/{residentId}/requests/{requestId}`
                .replace(`{${"residentId"}}`, encodeURIComponent(String(residentId)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResidentMaintenanceRequestsApi - functional programming interface
 * @export
 */
export const ResidentMaintenanceRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResidentMaintenanceRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels a maintenance request for the specified resident.
         * @summary Cancel a maintenance request for a resident
         * @param {string} residentId UUID of the resident
         * @param {string} requestId UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(residentId: string, requestId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(residentId, requestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentMaintenanceRequestsApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new maintenance request for the specified resident.
         * @summary Create a new maintenance request for a resident
         * @param {string} residentId UUID of the resident
         * @param {CreateRequestDto} createRequestDto Maintenance request creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create2(residentId: string, createRequestDto: CreateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create2(residentId, createRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentMaintenanceRequestsApi.create2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a maintenance request by its unique identifier for the specified resident.
         * @summary Get a maintenance request by ID for a resident
         * @param {string} residentId UUID of the resident
         * @param {string} requestId UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(residentId: string, requestId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(residentId, requestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentMaintenanceRequestsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all maintenance requests for the specified resident.
         * @summary List all maintenance requests for a resident
         * @param {string} residentId UUID of the resident
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(residentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaintenanceRequestDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(residentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentMaintenanceRequestsApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing maintenance request for the specified resident.
         * @summary Update a maintenance request for a resident
         * @param {string} residentId UUID of the resident
         * @param {string} requestId UUID of the maintenance request
         * @param {UpdateRequestDto} updateRequestDto Maintenance request update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update4(residentId: string, requestId: string, updateRequestDto: UpdateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update4(residentId, requestId, updateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentMaintenanceRequestsApi.update4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResidentMaintenanceRequestsApi - factory interface
 * @export
 */
export const ResidentMaintenanceRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResidentMaintenanceRequestsApiFp(configuration)
    return {
        /**
         * Cancels a maintenance request for the specified resident.
         * @summary Cancel a maintenance request for a resident
         * @param {string} residentId UUID of the resident
         * @param {string} requestId UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(residentId: string, requestId: string, options?: RawAxiosRequestConfig): AxiosPromise<CancelResponseDto> {
            return localVarFp.cancel(residentId, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new maintenance request for the specified resident.
         * @summary Create a new maintenance request for a resident
         * @param {string} residentId UUID of the resident
         * @param {CreateRequestDto} createRequestDto Maintenance request creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(residentId: string, createRequestDto: CreateRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceRequestDto> {
            return localVarFp.create2(residentId, createRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a maintenance request by its unique identifier for the specified resident.
         * @summary Get a maintenance request by ID for a resident
         * @param {string} residentId UUID of the resident
         * @param {string} requestId UUID of the maintenance request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(residentId: string, requestId: string, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceRequestDto> {
            return localVarFp.get(residentId, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all maintenance requests for the specified resident.
         * @summary List all maintenance requests for a resident
         * @param {string} residentId UUID of the resident
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(residentId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MaintenanceRequestDto>> {
            return localVarFp.list(residentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing maintenance request for the specified resident.
         * @summary Update a maintenance request for a resident
         * @param {string} residentId UUID of the resident
         * @param {string} requestId UUID of the maintenance request
         * @param {UpdateRequestDto} updateRequestDto Maintenance request update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4(residentId: string, requestId: string, updateRequestDto: UpdateRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceRequestDto> {
            return localVarFp.update4(residentId, requestId, updateRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResidentMaintenanceRequestsApi - object-oriented interface
 * @export
 * @class ResidentMaintenanceRequestsApi
 * @extends {BaseAPI}
 */
export class ResidentMaintenanceRequestsApi extends BaseAPI {
    /**
     * Cancels a maintenance request for the specified resident.
     * @summary Cancel a maintenance request for a resident
     * @param {string} residentId UUID of the resident
     * @param {string} requestId UUID of the maintenance request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentMaintenanceRequestsApi
     */
    public cancel(residentId: string, requestId: string, options?: RawAxiosRequestConfig) {
        return ResidentMaintenanceRequestsApiFp(this.configuration).cancel(residentId, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new maintenance request for the specified resident.
     * @summary Create a new maintenance request for a resident
     * @param {string} residentId UUID of the resident
     * @param {CreateRequestDto} createRequestDto Maintenance request creation data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentMaintenanceRequestsApi
     */
    public create2(residentId: string, createRequestDto: CreateRequestDto, options?: RawAxiosRequestConfig) {
        return ResidentMaintenanceRequestsApiFp(this.configuration).create2(residentId, createRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a maintenance request by its unique identifier for the specified resident.
     * @summary Get a maintenance request by ID for a resident
     * @param {string} residentId UUID of the resident
     * @param {string} requestId UUID of the maintenance request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentMaintenanceRequestsApi
     */
    public get(residentId: string, requestId: string, options?: RawAxiosRequestConfig) {
        return ResidentMaintenanceRequestsApiFp(this.configuration).get(residentId, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all maintenance requests for the specified resident.
     * @summary List all maintenance requests for a resident
     * @param {string} residentId UUID of the resident
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentMaintenanceRequestsApi
     */
    public list(residentId: string, options?: RawAxiosRequestConfig) {
        return ResidentMaintenanceRequestsApiFp(this.configuration).list(residentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing maintenance request for the specified resident.
     * @summary Update a maintenance request for a resident
     * @param {string} residentId UUID of the resident
     * @param {string} requestId UUID of the maintenance request
     * @param {UpdateRequestDto} updateRequestDto Maintenance request update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentMaintenanceRequestsApi
     */
    public update4(residentId: string, requestId: string, updateRequestDto: UpdateRequestDto, options?: RawAxiosRequestConfig) {
        return ResidentMaintenanceRequestsApiFp(this.configuration).update4(residentId, requestId, updateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResidentManagementApi - axios parameter creator
 * @export
 */
export const ResidentManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new resident with the provided details.
         * @summary Create a new resident
         * @param {ResidentCreateCommandDto} residentCreateCommandDto Resident creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (residentCreateCommandDto: ResidentCreateCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'residentCreateCommandDto' is not null or undefined
            assertParamExists('create1', 'residentCreateCommandDto', residentCreateCommandDto)
            const localVarPath = `/residents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(residentCreateCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a resident by their ID.
         * @summary Delete a resident
         * @param {string} id UUID of the resident
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete1', 'id', id)
            const localVarPath = `/residents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a resident by their unique identifier.
         * @summary Get a resident by ID
         * @param {string} id UUID of the resident
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOne1', 'id', id)
            const localVarPath = `/residents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all residents.
         * @summary List all residents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/residents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing resident by their ID.
         * @summary Update a resident
         * @param {string} id UUID of the resident
         * @param {ResidentUpdateCommandDto} residentUpdateCommandDto Resident update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: async (id: string, residentUpdateCommandDto: ResidentUpdateCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update1', 'id', id)
            // verify required parameter 'residentUpdateCommandDto' is not null or undefined
            assertParamExists('update1', 'residentUpdateCommandDto', residentUpdateCommandDto)
            const localVarPath = `/residents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(residentUpdateCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResidentManagementApi - functional programming interface
 * @export
 */
export const ResidentManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResidentManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new resident with the provided details.
         * @summary Create a new resident
         * @param {ResidentCreateCommandDto} residentCreateCommandDto Resident creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(residentCreateCommandDto: ResidentCreateCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResidentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create1(residentCreateCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentManagementApi.create1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a resident by their ID.
         * @summary Delete a resident
         * @param {string} id UUID of the resident
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentManagementApi.delete1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a resident by their unique identifier.
         * @summary Get a resident by ID
         * @param {string} id UUID of the resident
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOne1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResidentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOne1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentManagementApi.getOne1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all residents.
         * @summary List all residents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAll1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResidentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAll1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentManagementApi.listAll1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing resident by their ID.
         * @summary Update a resident
         * @param {string} id UUID of the resident
         * @param {ResidentUpdateCommandDto} residentUpdateCommandDto Resident update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update1(id: string, residentUpdateCommandDto: ResidentUpdateCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResidentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update1(id, residentUpdateCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentManagementApi.update1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResidentManagementApi - factory interface
 * @export
 */
export const ResidentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResidentManagementApiFp(configuration)
    return {
        /**
         * Creates a new resident with the provided details.
         * @summary Create a new resident
         * @param {ResidentCreateCommandDto} residentCreateCommandDto Resident creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(residentCreateCommandDto: ResidentCreateCommandDto, options?: RawAxiosRequestConfig): AxiosPromise<ResidentDto> {
            return localVarFp.create1(residentCreateCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a resident by their ID.
         * @summary Delete a resident
         * @param {string} id UUID of the resident
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteResponseDto> {
            return localVarFp.delete1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a resident by their unique identifier.
         * @summary Get a resident by ID
         * @param {string} id UUID of the resident
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResidentDto> {
            return localVarFp.getOne1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all residents.
         * @summary List all residents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll1(options?: RawAxiosRequestConfig): AxiosPromise<Array<ResidentDto>> {
            return localVarFp.listAll1(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing resident by their ID.
         * @summary Update a resident
         * @param {string} id UUID of the resident
         * @param {ResidentUpdateCommandDto} residentUpdateCommandDto Resident update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(id: string, residentUpdateCommandDto: ResidentUpdateCommandDto, options?: RawAxiosRequestConfig): AxiosPromise<ResidentDto> {
            return localVarFp.update1(id, residentUpdateCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResidentManagementApi - object-oriented interface
 * @export
 * @class ResidentManagementApi
 * @extends {BaseAPI}
 */
export class ResidentManagementApi extends BaseAPI {
    /**
     * Creates a new resident with the provided details.
     * @summary Create a new resident
     * @param {ResidentCreateCommandDto} residentCreateCommandDto Resident creation data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentManagementApi
     */
    public create1(residentCreateCommandDto: ResidentCreateCommandDto, options?: RawAxiosRequestConfig) {
        return ResidentManagementApiFp(this.configuration).create1(residentCreateCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a resident by their ID.
     * @summary Delete a resident
     * @param {string} id UUID of the resident
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentManagementApi
     */
    public delete1(id: string, options?: RawAxiosRequestConfig) {
        return ResidentManagementApiFp(this.configuration).delete1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a resident by their unique identifier.
     * @summary Get a resident by ID
     * @param {string} id UUID of the resident
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentManagementApi
     */
    public getOne1(id: string, options?: RawAxiosRequestConfig) {
        return ResidentManagementApiFp(this.configuration).getOne1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all residents.
     * @summary List all residents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentManagementApi
     */
    public listAll1(options?: RawAxiosRequestConfig) {
        return ResidentManagementApiFp(this.configuration).listAll1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing resident by their ID.
     * @summary Update a resident
     * @param {string} id UUID of the resident
     * @param {ResidentUpdateCommandDto} residentUpdateCommandDto Resident update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentManagementApi
     */
    public update1(id: string, residentUpdateCommandDto: ResidentUpdateCommandDto, options?: RawAxiosRequestConfig) {
        return ResidentManagementApiFp(this.configuration).update1(id, residentUpdateCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResidentialComplexManagementApi - axios parameter creator
 * @export
 */
export const ResidentialComplexManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new residential complex with the provided details.
         * @summary Create a new residential complex
         * @param {ResidentialComplexCommandDto} residentialComplexCommandDto Residential complex creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3: async (residentialComplexCommandDto: ResidentialComplexCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'residentialComplexCommandDto' is not null or undefined
            assertParamExists('create3', 'residentialComplexCommandDto', residentialComplexCommandDto)
            const localVarPath = `/residential-complexes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(residentialComplexCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a residential complex by its ID.
         * @summary Delete a residential complex
         * @param {string} id UUID of the residential complex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete2', 'id', id)
            const localVarPath = `/residential-complexes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a residential complex by its unique identifier.
         * @summary Get a residential complex by ID
         * @param {string} id UUID of the residential complex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOne2', 'id', id)
            const localVarPath = `/residential-complexes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all residential complexes.
         * @summary List all residential complexes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/residential-complexes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing residential complex by its ID.
         * @summary Update a residential complex
         * @param {string} id UUID of the residential complex
         * @param {ResidentialComplexCommandDto} residentialComplexCommandDto Residential complex update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2: async (id: string, residentialComplexCommandDto: ResidentialComplexCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update2', 'id', id)
            // verify required parameter 'residentialComplexCommandDto' is not null or undefined
            assertParamExists('update2', 'residentialComplexCommandDto', residentialComplexCommandDto)
            const localVarPath = `/residential-complexes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(residentialComplexCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResidentialComplexManagementApi - functional programming interface
 * @export
 */
export const ResidentialComplexManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResidentialComplexManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new residential complex with the provided details.
         * @summary Create a new residential complex
         * @param {ResidentialComplexCommandDto} residentialComplexCommandDto Residential complex creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create3(residentialComplexCommandDto: ResidentialComplexCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResidentialComplexDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create3(residentialComplexCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentialComplexManagementApi.create3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a residential complex by its ID.
         * @summary Delete a residential complex
         * @param {string} id UUID of the residential complex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentialComplexManagementApi.delete2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a residential complex by its unique identifier.
         * @summary Get a residential complex by ID
         * @param {string} id UUID of the residential complex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOne2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResidentialComplexDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOne2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentialComplexManagementApi.getOne2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all residential complexes.
         * @summary List all residential complexes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAll2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResidentialComplexDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAll2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentialComplexManagementApi.listAll2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing residential complex by its ID.
         * @summary Update a residential complex
         * @param {string} id UUID of the residential complex
         * @param {ResidentialComplexCommandDto} residentialComplexCommandDto Residential complex update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update2(id: string, residentialComplexCommandDto: ResidentialComplexCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResidentialComplexDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update2(id, residentialComplexCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResidentialComplexManagementApi.update2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResidentialComplexManagementApi - factory interface
 * @export
 */
export const ResidentialComplexManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResidentialComplexManagementApiFp(configuration)
    return {
        /**
         * Creates a new residential complex with the provided details.
         * @summary Create a new residential complex
         * @param {ResidentialComplexCommandDto} residentialComplexCommandDto Residential complex creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(residentialComplexCommandDto: ResidentialComplexCommandDto, options?: RawAxiosRequestConfig): AxiosPromise<ResidentialComplexDto> {
            return localVarFp.create3(residentialComplexCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a residential complex by its ID.
         * @summary Delete a residential complex
         * @param {string} id UUID of the residential complex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteResponseDto> {
            return localVarFp.delete2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a residential complex by its unique identifier.
         * @summary Get a residential complex by ID
         * @param {string} id UUID of the residential complex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne2(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResidentialComplexDto> {
            return localVarFp.getOne2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all residential complexes.
         * @summary List all residential complexes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll2(options?: RawAxiosRequestConfig): AxiosPromise<Array<ResidentialComplexDto>> {
            return localVarFp.listAll2(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing residential complex by its ID.
         * @summary Update a residential complex
         * @param {string} id UUID of the residential complex
         * @param {ResidentialComplexCommandDto} residentialComplexCommandDto Residential complex update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(id: string, residentialComplexCommandDto: ResidentialComplexCommandDto, options?: RawAxiosRequestConfig): AxiosPromise<ResidentialComplexDto> {
            return localVarFp.update2(id, residentialComplexCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResidentialComplexManagementApi - object-oriented interface
 * @export
 * @class ResidentialComplexManagementApi
 * @extends {BaseAPI}
 */
export class ResidentialComplexManagementApi extends BaseAPI {
    /**
     * Creates a new residential complex with the provided details.
     * @summary Create a new residential complex
     * @param {ResidentialComplexCommandDto} residentialComplexCommandDto Residential complex creation data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentialComplexManagementApi
     */
    public create3(residentialComplexCommandDto: ResidentialComplexCommandDto, options?: RawAxiosRequestConfig) {
        return ResidentialComplexManagementApiFp(this.configuration).create3(residentialComplexCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a residential complex by its ID.
     * @summary Delete a residential complex
     * @param {string} id UUID of the residential complex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentialComplexManagementApi
     */
    public delete2(id: string, options?: RawAxiosRequestConfig) {
        return ResidentialComplexManagementApiFp(this.configuration).delete2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a residential complex by its unique identifier.
     * @summary Get a residential complex by ID
     * @param {string} id UUID of the residential complex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentialComplexManagementApi
     */
    public getOne2(id: string, options?: RawAxiosRequestConfig) {
        return ResidentialComplexManagementApiFp(this.configuration).getOne2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all residential complexes.
     * @summary List all residential complexes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentialComplexManagementApi
     */
    public listAll2(options?: RawAxiosRequestConfig) {
        return ResidentialComplexManagementApiFp(this.configuration).listAll2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing residential complex by its ID.
     * @summary Update a residential complex
     * @param {string} id UUID of the residential complex
     * @param {ResidentialComplexCommandDto} residentialComplexCommandDto Residential complex update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResidentialComplexManagementApi
     */
    public update2(id: string, residentialComplexCommandDto: ResidentialComplexCommandDto, options?: RawAxiosRequestConfig) {
        return ResidentialComplexManagementApiFp(this.configuration).update2(id, residentialComplexCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TechnicianMaintenanceRequestsApi - axios parameter creator
 * @export
 */
export const TechnicianMaintenanceRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows a technician to change the status of an assigned maintenance request.
         * @summary Change the status of a maintenance request
         * @param {string} technicianId UUID of the technician
         * @param {string} requestId UUID of the maintenance request
         * @param {ChangeStatusDto} changeStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeStatus: async (technicianId: string, requestId: string, changeStatusDto: ChangeStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'technicianId' is not null or undefined
            assertParamExists('changeStatus', 'technicianId', technicianId)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('changeStatus', 'requestId', requestId)
            // verify required parameter 'changeStatusDto' is not null or undefined
            assertParamExists('changeStatus', 'changeStatusDto', changeStatusDto)
            const localVarPath = `/technicians/{technicianId}/requests/{requestId}/status`
                .replace(`{${"technicianId"}}`, encodeURIComponent(String(technicianId)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all maintenance requests assigned to the specified technician.
         * @summary List all maintenance requests assigned to a technician
         * @param {string} technicianId UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1: async (technicianId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'technicianId' is not null or undefined
            assertParamExists('list1', 'technicianId', technicianId)
            const localVarPath = `/technicians/{technicianId}/requests`
                .replace(`{${"technicianId"}}`, encodeURIComponent(String(technicianId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TechnicianMaintenanceRequestsApi - functional programming interface
 * @export
 */
export const TechnicianMaintenanceRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TechnicianMaintenanceRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows a technician to change the status of an assigned maintenance request.
         * @summary Change the status of a maintenance request
         * @param {string} technicianId UUID of the technician
         * @param {string} requestId UUID of the maintenance request
         * @param {ChangeStatusDto} changeStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeStatus(technicianId: string, requestId: string, changeStatusDto: ChangeStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeStatus(technicianId, requestId, changeStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TechnicianMaintenanceRequestsApi.changeStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all maintenance requests assigned to the specified technician.
         * @summary List all maintenance requests assigned to a technician
         * @param {string} technicianId UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list1(technicianId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaintenanceRequestDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list1(technicianId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TechnicianMaintenanceRequestsApi.list1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TechnicianMaintenanceRequestsApi - factory interface
 * @export
 */
export const TechnicianMaintenanceRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TechnicianMaintenanceRequestsApiFp(configuration)
    return {
        /**
         * Allows a technician to change the status of an assigned maintenance request.
         * @summary Change the status of a maintenance request
         * @param {string} technicianId UUID of the technician
         * @param {string} requestId UUID of the maintenance request
         * @param {ChangeStatusDto} changeStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeStatus(technicianId: string, requestId: string, changeStatusDto: ChangeStatusDto, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceRequestDto> {
            return localVarFp.changeStatus(technicianId, requestId, changeStatusDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all maintenance requests assigned to the specified technician.
         * @summary List all maintenance requests assigned to a technician
         * @param {string} technicianId UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1(technicianId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MaintenanceRequestDto>> {
            return localVarFp.list1(technicianId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TechnicianMaintenanceRequestsApi - object-oriented interface
 * @export
 * @class TechnicianMaintenanceRequestsApi
 * @extends {BaseAPI}
 */
export class TechnicianMaintenanceRequestsApi extends BaseAPI {
    /**
     * Allows a technician to change the status of an assigned maintenance request.
     * @summary Change the status of a maintenance request
     * @param {string} technicianId UUID of the technician
     * @param {string} requestId UUID of the maintenance request
     * @param {ChangeStatusDto} changeStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TechnicianMaintenanceRequestsApi
     */
    public changeStatus(technicianId: string, requestId: string, changeStatusDto: ChangeStatusDto, options?: RawAxiosRequestConfig) {
        return TechnicianMaintenanceRequestsApiFp(this.configuration).changeStatus(technicianId, requestId, changeStatusDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all maintenance requests assigned to the specified technician.
     * @summary List all maintenance requests assigned to a technician
     * @param {string} technicianId UUID of the technician
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TechnicianMaintenanceRequestsApi
     */
    public list1(technicianId: string, options?: RawAxiosRequestConfig) {
        return TechnicianMaintenanceRequestsApiFp(this.configuration).list1(technicianId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TechnicianManagementApi - axios parameter creator
 * @export
 */
export const TechnicianManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a technician by their ID.
         * @summary Delete a technician
         * @param {string} id UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/technicians/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new technician with the provided details.
         * @summary Create a new technician
         * @param {TechnicianCreateCommandDto} technicianCreateCommandDto Technician creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (technicianCreateCommandDto: TechnicianCreateCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'technicianCreateCommandDto' is not null or undefined
            assertParamExists('create', 'technicianCreateCommandDto', technicianCreateCommandDto)
            const localVarPath = `/technicians`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(technicianCreateCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a technician by their unique identifier.
         * @summary Get a technician by ID
         * @param {string} id UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOne', 'id', id)
            const localVarPath = `/technicians/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all technicians.
         * @summary List all technicians
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/technicians`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing technician by their ID.
         * @summary Update a technician
         * @param {string} id UUID of the technician
         * @param {TechnicianUpdateCommandDto} technicianUpdateCommandDto Technician update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, technicianUpdateCommandDto: TechnicianUpdateCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'technicianUpdateCommandDto' is not null or undefined
            assertParamExists('update', 'technicianUpdateCommandDto', technicianUpdateCommandDto)
            const localVarPath = `/technicians/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(technicianUpdateCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TechnicianManagementApi - functional programming interface
 * @export
 */
export const TechnicianManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TechnicianManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a technician by their ID.
         * @summary Delete a technician
         * @param {string} id UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TechnicianManagementApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new technician with the provided details.
         * @summary Create a new technician
         * @param {TechnicianCreateCommandDto} technicianCreateCommandDto Technician creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(technicianCreateCommandDto: TechnicianCreateCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TechnicianDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(technicianCreateCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TechnicianManagementApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a technician by their unique identifier.
         * @summary Get a technician by ID
         * @param {string} id UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TechnicianDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TechnicianManagementApi.getOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all technicians.
         * @summary List all technicians
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TechnicianDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TechnicianManagementApi.listAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing technician by their ID.
         * @summary Update a technician
         * @param {string} id UUID of the technician
         * @param {TechnicianUpdateCommandDto} technicianUpdateCommandDto Technician update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, technicianUpdateCommandDto: TechnicianUpdateCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TechnicianDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, technicianUpdateCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TechnicianManagementApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TechnicianManagementApi - factory interface
 * @export
 */
export const TechnicianManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TechnicianManagementApiFp(configuration)
    return {
        /**
         * Deletes a technician by their ID.
         * @summary Delete a technician
         * @param {string} id UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteResponseDto> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new technician with the provided details.
         * @summary Create a new technician
         * @param {TechnicianCreateCommandDto} technicianCreateCommandDto Technician creation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(technicianCreateCommandDto: TechnicianCreateCommandDto, options?: RawAxiosRequestConfig): AxiosPromise<TechnicianDto> {
            return localVarFp.create(technicianCreateCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a technician by their unique identifier.
         * @summary Get a technician by ID
         * @param {string} id UUID of the technician
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TechnicianDto> {
            return localVarFp.getOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all technicians.
         * @summary List all technicians
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<TechnicianDto>> {
            return localVarFp.listAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing technician by their ID.
         * @summary Update a technician
         * @param {string} id UUID of the technician
         * @param {TechnicianUpdateCommandDto} technicianUpdateCommandDto Technician update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, technicianUpdateCommandDto: TechnicianUpdateCommandDto, options?: RawAxiosRequestConfig): AxiosPromise<TechnicianDto> {
            return localVarFp.update(id, technicianUpdateCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TechnicianManagementApi - object-oriented interface
 * @export
 * @class TechnicianManagementApi
 * @extends {BaseAPI}
 */
export class TechnicianManagementApi extends BaseAPI {
    /**
     * Deletes a technician by their ID.
     * @summary Delete a technician
     * @param {string} id UUID of the technician
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TechnicianManagementApi
     */
    public _delete(id: string, options?: RawAxiosRequestConfig) {
        return TechnicianManagementApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new technician with the provided details.
     * @summary Create a new technician
     * @param {TechnicianCreateCommandDto} technicianCreateCommandDto Technician creation data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TechnicianManagementApi
     */
    public create(technicianCreateCommandDto: TechnicianCreateCommandDto, options?: RawAxiosRequestConfig) {
        return TechnicianManagementApiFp(this.configuration).create(technicianCreateCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a technician by their unique identifier.
     * @summary Get a technician by ID
     * @param {string} id UUID of the technician
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TechnicianManagementApi
     */
    public getOne(id: string, options?: RawAxiosRequestConfig) {
        return TechnicianManagementApiFp(this.configuration).getOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all technicians.
     * @summary List all technicians
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TechnicianManagementApi
     */
    public listAll(options?: RawAxiosRequestConfig) {
        return TechnicianManagementApiFp(this.configuration).listAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing technician by their ID.
     * @summary Update a technician
     * @param {string} id UUID of the technician
     * @param {TechnicianUpdateCommandDto} technicianUpdateCommandDto Technician update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TechnicianManagementApi
     */
    public update(id: string, technicianUpdateCommandDto: TechnicianUpdateCommandDto, options?: RawAxiosRequestConfig) {
        return TechnicianManagementApiFp(this.configuration).update(id, technicianUpdateCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserInfoApi - axios parameter creator
 * @export
 */
export const UserInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information about the currently authenticated user, including their role, relationships, and related maintenance requests.
         * @summary Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserInfoApi - functional programming interface
 * @export
 */
export const UserInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns information about the currently authenticated user, including their role, relationships, and related maintenance requests.
         * @summary Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserInfoApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserInfoApi - factory interface
 * @export
 */
export const UserInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserInfoApiFp(configuration)
    return {
        /**
         * Returns information about the currently authenticated user, including their role, relationships, and related maintenance requests.
         * @summary Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<UserInfoDto> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserInfoApi - object-oriented interface
 * @export
 * @class UserInfoApi
 * @extends {BaseAPI}
 */
export class UserInfoApi extends BaseAPI {
    /**
     * Returns information about the currently authenticated user, including their role, relationships, and related maintenance requests.
     * @summary Get current user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInfoApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UserInfoApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }
}



